--- boot.cmd.in.old
+++ boot.cmd.in
@@ -2,28 +2,8 @@
 #
 # Copyright 2020 Toradex
 #
-# Toradex boot script.
-#
-# Allows to change boot and rootfs devices independently.
-# Supports:
-# - boot device type: boot_devtype := {mmc, usb, dhcp}
-# - boot device num (for mmc, usb types): boot_devnum := {0 .. MAX_DEV_NUM}
-# - boot partition (for mmc, usb types): boot_part := {1 .. MAX_PART_NUM}
-# - root device type: root_devtype := {mmc, usb, dhcp}
-# - root device num (for mmc, usb types): root_devnum := {0 .. MAX_DEV_NUM}
-# - root partition (for mmc, usb types): root_part := {1 .. MAX_PART_NUM}
-#
-# Defaults:
-#    root_devtype = boot_devtype = devtype
-#    root_devnum = boot_devnum = devnum
-#    boot_part = distro_bootpart
-#    root_part = 2
-#
-# Common flags:
-# - Skip loading overlays: skip_fdt_overlays := {1, 0}
-#   1 - skip, any other value (or undefined variable) - don't skip.
-#   This variable is adopted from the TorizonCore and shouldn't be
-#   renamed separately.
+# With Mender integration.
+# Only supports booting from mmc
 
 if test ${devtype} = "ubi"; then
     echo "This script is not meant to distro boot from raw NAND flash."
@@ -36,26 +16,20 @@ test ${devtype} = "ethernet" && env set devtype "dhcp"
 
 test -n ${m4boot} || env set m4boot ';'
 test -n ${fdtfile} || env set fdtfile ${fdt_file}
-test -n ${boot_part} || env set boot_part ${distro_bootpart}
-test -n ${root_part} || env set root_part 2
-test -n ${boot_devnum} || env set boot_devnum ${devnum}
-test -n ${root_devnum} || env set root_devnum ${devnum}
 test -n ${kernel_image} || env set kernel_image @@KERNEL_IMAGETYPE@@
-test -n ${boot_devtype} || env set boot_devtype ${devtype}
-test -n ${root_devtype} || env set root_devtype ${devtype}
+if test ${kernel_image} = "fitImage"; then
+    echo "Booting signed FIT image"
+fi
+
 test -n ${overlays_file} || env set overlays_file "overlays.txt"
-test -n ${overlays_prefix} || env set overlays_prefix "overlays/"
+test -n ${overlays_prefix} || env set overlays_prefix "boot/overlays/"
 test -n ${fitconf_fdt_overlays} || env set fitconf_fdt_overlays '@@FITCONF_FDT_OVERLAYS@@'
-
-test ${boot_devtype} = "mmc" && env set load_cmd 'load ${boot_devtype} ${boot_devnum}:${boot_part}'
-test ${boot_devtype} = "usb" && env set load_cmd 'load ${boot_devtype} ${boot_devnum}:${boot_part}'
-test ${boot_devtype} = "tftp" && env set load_cmd 'tftp'
-test ${boot_devtype} = "dhcp" && env set load_cmd 'dhcp'
+test -n ${fit_conf} || env set fit_conf "conf-freescale_imx8mp-verdin-nonwifi-dahlia.dtb"
 
 # Set console baudrate only when required
 setexpr _res sub "," "_" ${console}
 if test "${_res}" = "" -o "${_res}" = "${console}"; then
-	env set console "${console},${baudrate}"
+    env set console "${console},${baudrate}"
 fi
 
 env set appendargs @@APPEND@@
@@ -65,7 +39,6 @@ env set bootcmd_unzip ';'
 if test ${kernel_image} = "fitImage"; then
     env set kernel_addr_load ${ramdisk_addr_r}
 elif test -n ${kernel_comp_addr_r}; then
-    # use booti automatic decompression
     env set kernel_addr_load ${loadaddr}
 elif test ${kernel_image} = "Image.gz"; then
     env set kernel_addr_load ${loadaddr}
@@ -74,39 +47,43 @@ else
     env set kernel_addr_load ${kernel_addr_r}
 fi
 
-# Set dynamic commands
-env set set_bootcmd_kernel 'env set bootcmd_kernel "${load_cmd} \\${kernel_addr_load} \\${kernel_image}"'
-env set set_load_overlays_file 'env set load_overlays_file "${load_cmd} \\${loadaddr} \\${overlays_file} && env import -t \\${loadaddr} \\${filesize}"'
-if test ${kernel_image} = "fitImage"; then
-    env set fdt_high
-    env set fdt_resize true
-    env set set_bootcmd_dtb 'env set bootcmd_dtb "true"'
-    env set set_apply_overlays 'env set apply_overlays "for overlay_file in \"\\${fdt_overlays}\"; do env set fitconf_fdt_overlays \"\\"\\${fitconf_fdt_overlays}#conf-\\${overlay_file}\\"\"; env set overlay_file; done; true"'
-    env set bootcmd_boot 'echo "Bootargs: \${bootargs}" && bootm ${kernel_addr_load}#conf-@@KERNEL_DTB_PREFIX@@\${fdtfile}\${fitconf_fdt_overlays}'
-else
-    env set fdt_resize 'fdt addr ${fdt_addr_r} && fdt resize 0x20000'
-    env set set_bootcmd_dtb 'env set bootcmd_dtb "echo Loading DeviceTree: \\${fdtfile}; ${load_cmd} \\${fdt_addr_r} \\${fdtfile}"'
-    env set set_apply_overlays 'env set apply_overlays "for overlay_file in \\${fdt_overlays}; do echo Applying Overlay: \\${overlay_file} && ${load_cmd} \\${loadaddr} \\${overlays_prefix}\\${overlay_file} && fdt apply \\${loadaddr}; env set overlay_file; done; true"'
-    env set bootcmd_boot 'echo "Bootargs: \${bootargs}" && @@KERNEL_BOOTCMD@@ ${kernel_addr_r} - ${fdt_addr_r}'
-fi
+env set mender_setup 'if test "${mender_saveenv_canary}" != "1"; then setenv mender_saveenv_canary 1; saveenv; fi; if test "${mender_pre_setup_commands}" != ""; then run mender_pre_setup_commands; fi; if test "${mender_systemd_machine_id}" != ""; then setenv bootargs "systemd.machine_id=${mender_systemd_machine_id} ${bootargs}"; fi; setenv mender_kernel_root /dev/mmcblk1p${mender_boot_part}; if test ${mender_boot_part} = 2; then setenv mender_boot_part_name /dev/mmcblk1p2; else setenv mender_boot_part_name /dev/mmcblk1p3; fi; setenv mender_kernel_root_name ${mender_boot_part_name}; setenv mender_uboot_root mmc 1:${mender_boot_part_hex}; setenv mender_uboot_root_name ${mender_boot_part_name}; setenv expand_bootargs "setenv bootargs \\"${bootargs}\\""; run expand_bootargs; setenv expand_bootargs; if test "${mender_post_setup_commands}" != ""; then run mender_post_setup_commands; fi'
 
-# Set static commands
-if test ${root_devtype} = "dhcp"; then
-    env set rootfsargs_set 'env set rootfsargs "root=/dev/nfs nfsroot=${serverip}:/${rootpath} ip=dhcp"'
+# Mender-specific commands
+env set load_prefix 'boot/'
+env set load_cmd 'load ${mender_uboot_root}'
+env set load_cmd_boot 'load ${mender_uboot_boot}'
+env set set_bootcmd_kernel 'env set bootcmd_kernel "${load_cmd} \\${kernel_addr_load} \\${load_prefix}\\${kernel_image}"'
+env set set_load_overlays_file 'env set load_overlays_file "${load_cmd} \\${loadaddr} \\${load_prefix}\\${overlays_file}; env import -t \\${loadaddr} \\${filesize}"'
+env set fdt_resize 'fdt addr ${fdt_addr_r} && fdt resize 0x20000'
+env set set_bootcmd_dtb 'env set bootcmd_dtb "echo Loading DeviceTree: \\${fdtfile}; ${load_cmd} \\${fdt_addr_r} \\${load_prefix}/freescale/\\${fdtfile}"'
+env set set_apply_overlays 'env set apply_overlays "for overlay_file in \\${fdt_overlays}; do echo Applying Overlay: \\${overlay_file} && ${load_cmd} \\${loadaddr} \\${overlays_prefix}\\${overlay_file} && fdt apply \\${loadaddr}; env set overlay_file; done; true"'
+
+if test ${kernel_image} = "fitImage"; then
+    env set bootcmd_boot 'echo "Bootargs: ${bootargs}" && echo "Using FIT config: ${fit_conf}" && bootm ${kernel_addr_load}#${fit_conf}'
 else
-    env set uuid_set 'part uuid ${root_devtype} ${root_devnum}:${root_part} uuid'
-    env set rootfsargs_set 'run uuid_set && env set rootfsargs "root=PARTUUID=${uuid} ro rootwait"'
+    env set bootcmd_boot 'echo "Bootargs: ${bootargs}" && @@KERNEL_BOOTCMD@@ ${kernel_addr_r} - ${fdt_addr_r}'
 fi
 
+env set rootfsargs_set 'env set rootfsargs root=${mender_kernel_root} ro rootwait'
 env set bootcmd_args 'run rootfsargs_set && env set bootargs ${rootfsargs} ${setupargs} ${appendargs} ${tdxargs}'
+
 if test ${skip_fdt_overlays} != 1; then
     env set bootcmd_overlays 'run load_overlays_file && run fdt_resize && run apply_overlays'
 else
     env set bootcmd_overlays true
 fi
+
 env set bootcmd_prepare 'run set_bootcmd_kernel; run set_bootcmd_dtb; run set_load_overlays_file; run set_apply_overlays'
-env set bootcmd_run 'run m4boot; run bootcmd_dtb && run bootcmd_overlays && run bootcmd_args && run bootcmd_kernel && run bootcmd_unzip && run bootcmd_boot; echo "Booting from ${devtype} failed!" && false'
 
+if test ${kernel_image} = "fitImage"; then
+    env set bootcmd_run 'run m4boot; run bootcmd_args && run bootcmd_kernel && run bootcmd_boot; echo "Booting from ${devtype} failed!"'
+else
+    env set bootcmd_run 'run m4boot; run bootcmd_dtb && run bootcmd_overlays && run bootcmd_args && run bootcmd_kernel && run bootcmd_unzip && run bootcmd_boot; echo "Booting from ${devtype} failed!"'
+fi
+
+# Run preparation and boot
 run bootcmd_prepare
+run mender_setup
 run bootcmd_run
-
+run mender_try_to_recover
